`timescale 1ns / 1ps
// rom.sv
module rom(
    input logic [31:0] addr,
    output logic [31:0] data
);
    logic [31:0] rom[0:15];
 
    initial begin
        //rom[x]=32'b func7 _ rs2 _ rs1 _ f3 _ rd _ opcode; // R-Type
        rom[0] = 32'b0000000_00001_00010_000_00100_0110011;  // ADD //12 + 11 = 23
        rom[1] = 32'b0100000_00001_00010_000_00101_0110011;  // SUB //12 - 11 = 1
        //rom[x]=32'b imm7  _ rs2  _ rs1 _ f3 _ imm5 _ opcode; // S-Type
        rom[2] = 32'b0000000_00010_00000_010_01000_0100011;  //  sw x2, 8(ram0);
        // rom[2] = 32'b0000000_00001_00010_001_00110_0110011;  // SLL  //12 << 11 = 12 * 2^11 = 24576
        // rom[3] = 32'b0000000_00001_00010_101_00111_0110011;  // SRL //12 >> 11 = 12 / 2^11 = 0
        // rom[4] = 32'b0100000_00001_00010_101_01000_0110011;  // SRA //12 >>> 11 = 0
        // rom[5] = 32'b0000000_00001_00010_010_01001_0110011;  // SLT //(12 < 11)? 1 : 0 = 0
        // rom[6] = 32'b0000000_00001_00010_011_01010_0110011;  // SLTU //(12 < 11)? 1 : 0 = 0 (unsigned)
        // rom[7] = 32'b0000000_00001_00010_100_01011_0110011;  // XOR //12 ^ 11 = 7 //12=1100, 11=1011 -> 1^1=0, 1^0=1, 0^1=1, 0^1=1
        // rom[8] = 32'b0000000_00001_00010_110_01100_0110011;  // OR //12 | 11 = 15
        // rom[9] = 32'b0000000_00001_00010_111_01101_0110011;  // AND //12 & 11 = 8


    end

    assign data = rom[addr[31:2]];  //4의 배수로 가기 위해서 하위 2비트를 지움
endmodule
