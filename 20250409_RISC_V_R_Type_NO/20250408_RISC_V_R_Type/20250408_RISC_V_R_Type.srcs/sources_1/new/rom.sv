`timescale 1ns / 1ps
// rom.sv
module rom(
    input logic [31:0] addr,
    output logic [31:0] data
);
    logic [31:0] rom[0:15];
 
    initial begin
        //rom[x]=32'b func7 _ rs2 _ rs1 _ f3 _ rd _ opcode; // R-Type

        // ADD x4, x2, x1: funct7 = 0000000, funct3 = 000, rd = 00100
        rom[0] = 32'b0000000_00001_00010_000_00100_0110011;  // ADD //12 + 11 = 23

        // SUB x5, x2, x1: funct7 = 0100000, funct3 = 000, rd = 00101
        rom[1] = 32'b0100000_00001_00010_000_00101_0110011;  // SUB //12 - 11 = 1

        // SLL x6, x2, x1: funct7 = 0000000, funct3 = 001, rd = 00110
        rom[2] = 32'b0000000_00001_00010_001_00110_0110011;  // SLL  //12 << 11 = 12 * 2^11 = 24576

        // SRL x7, x2, x1: funct7 = 0000000, funct3 = 101, rd = 00111
        rom[3] = 32'b0000000_00001_00010_101_00111_0110011;  // SRL //12 >> 11 = 12 / 2^11 = 0

        // SRA x8, x2, x1: funct7 = 0100000, funct3 = 101, rd = 01000
        rom[4] = 32'b0100000_00001_00010_101_01000_0110011;  // SRA //12 >>> 11 = 0

        // SLT x9, x2, x1: funct7 = 0000000, funct3 = 010, rd = 01001
        rom[5] = 32'b0000000_00001_00010_010_01001_0110011;  // SLT //(12 < 11)? 1 : 0 = 0

        // SLTU x10, x2, x1: funct7 = 0000000, funct3 = 011, rd = 01010
        rom[6] = 32'b0000000_00001_00010_011_01010_0110011;  // SLTU //(12 < 11)? 1 : 0 = 0 (unsigned)

        // XOR x11, x2, x1: funct7 = 0000000, funct3 = 100, rd = 01011
        rom[7] = 32'b0000000_00001_00010_100_01011_0110011;  // XOR //12 ^ 11 = 7 //12=1100, 11=1011 -> 1^1=0, 1^0=1, 0^1=1, 0^1=1

        // OR x12, x2, x1: funct7 = 0000000, funct3 = 110, rd = 01100
        rom[8] = 32'b0000000_00001_00010_110_01100_0110011;  // OR //12 | 11 = 15

        // AND x13, x2, x1: funct7 = 0000000, funct3 = 111, rd = 01101
        rom[9] = 32'b0000000_00001_00010_111_01101_0110011;  // AND //12 & 11 = 8

    end

    assign data = rom[addr[31:2]];  //4의 배수로 가기 위해서 하위 2비트를 지움
endmodule
